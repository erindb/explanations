// ======== compatibility with  =========

var print = function(str) {
  console.log(str);
};

var get_prob = function(erp, value) {
  var value = value ? value : true;
  return Math.exp(erp.score([], value));
};

var printERP = function(erp) {
  var support = erp.support();
  var probs = map(function(x) {return Math.exp(erp.score([], x));}, support);
  print("var s = " + JSON.stringify(support) + ";");
  print("var p = " + JSON.stringify(probs) + ";");
  print("print(Enumerate(function() {return s[discrete(p)];}))")
};

var vizPrint = function(erp) {
  var support = erp.support();
  var probs = map(function(x) {return Math.exp(erp.score([], x));}, support);
  print("var s = " + JSON.stringify(support) + ";");
  print("var p = " + JSON.stringify(probs) + ";");
  print("vizPrint(Enumerate(function() {return s[discrete(p)];}))")
};

var worldstring = function(w) {
  return (w.goal?'G':'-') + (w.action?'A':'-') + (w.outcome?'O':'-');
};

var strPrint = function(erp) {
  var support = erp.support();
  var probs = map(function(x) {return Math.exp(erp.score([], x));}, support);
  print("var s = " + JSON.stringify(map(worldstring, support)) + ";");
  print("var p = " + JSON.stringify(probs) + ";");
  print("print(Enumerate(function() {return s[discrete(p)];}))")
};

var model = function(rand, vars, condition, consequents, initialRVs, stickiness) {
  var alpha = 1;

  // ======== other utilities =========

  var contextualEval = cache(function(proposition, world) {
    var context = reduce(
      function(keyVal, acc) {
        return acc + ' var ' + keyVal[0] + ' = ' + JSON.stringify(keyVal[1]) + ';';
      },
      "",
      _.pairs(world)
    );
    return webpplEval(context + proposition + ';');
  });

  // ======== parameters and counterfactual functions =========

  // parameter for how similar counterfactual world is to actual world
  // var stickiness = 0.5;

  var stickyRand = function(actualRVs) {
    var freshRVs = rand();
    return mapObject(function(key, val) {
      return flip(stickiness) ? actualRVs[key] : freshRVs[key];
    }, actualRVs);
  };

  var contextualEval = cache(function(proposition, world) {
    var context = reduce(
      function(keyVal, acc) {
        return acc + ' var ' + keyVal[0] + ' = ' + JSON.stringify(keyVal[1]) + ';';
      },
      "",
      _.pairs(world)
    );
    return webpplEval(context + proposition + ';');
  });

  var checkPossible = function(unfactoredERP) {
    var factorERP = Enumerate(function() {
      return sample(unfactoredERP).factor;
    });
    if (factorERP.score([], -Infinity) == 0) {
      // a sort of way of throwing errors if we try to evaluate an impossible utterance
      return 'impossible';
    } else {
      return Enumerate(function() {
        var result = sample(unfactoredERP);
        factor(result.factor);
        return result.result;
      });
    }
  };

  var counterfactualERP = function(ifA, thenB, actualRVs) {
    var unfactoredERP = Enumerate(function() {
      var counterfactualRVs = stickyRand(actualRVs);
      var counterfactualWorld = vars(counterfactualRVs);
      return {
        result: contextualEval(thenB, counterfactualWorld),
        factor: (contextualEval(ifA, counterfactualWorld) ? 0 : -Infinity)
      }
    });
    // let the counterfactual return impossible if it is
    return checkPossible(unfactoredERP);
  };

  // ======== literal meaning functions =========

  var because = function(conditionA, resultB, actualWorld, actualRVs) {
    var actuallyA = contextualEval(conditionA, actualWorld);
    var actuallyB = contextualEval(resultB, actualWorld);

    if (actuallyA & actuallyB) {;
      var ifNotA = "!(" + conditionA + ")";
      var thenNotB = "!(" + resultB + ")";

      var cfERP = counterfactualERP(ifNotA, thenNotB, actualRVs);

      return cfERP == 'impossible' ? -Infinity : cfERP.score([], true);;
    } else {
      return -Infinity;
    }
  };

  /*
     meaning_factor is -Infinity if the utterance is completely false
     in the world, 0 if the utterance is true, and for "because" utterances
     it is the proportion of counterfactual worlds satisfying conditionA
     in which resultB is also true.
  */
  var meaning_factor = cache(function(utterance, world, rVs) {
    if (utterance == 'nothing') {
      return 0; // saying nothing doesn't update prior beliefs
    } else {
      var words = utterance.split(' ');

      // if the utterance doesn't have "because" in it, just evaluate it in the world
      if (words.length < 2 | words[1] != 'because') {
        var isTrue = contextualEval(words.join(' '), world);
        return (isTrue ? 0 : -Infinity);
      } else {
        // "resultB because conditionA"
        var resultB = words[0];
        var conditionA = words[2];

        var becauseFactor = because(conditionA, resultB, world, rVs);
        return becauseFactor;
      }
    }
  });

  var literalERP = cache(function(utterance, presup) {
    var unfactoredERP = Enumerate(function() {
      var actualRVs = rand();
      var actualWorld = vars(actualRVs);
      return {
        factor: meaning_factor(utterance, actualWorld, actualRVs) + meaning_factor(presup, actualWorld),
        result: actualWorld
      };
    });
    return checkPossible(unfactoredERP);
  });

  var marginalize = function(erp, variable) {
    return Enumerate(function() {
      var res = sample(erp);
      return res[variable];
    });
  };

  // utility to get cost of utterance based on number of words
  var getCostUtterance = function(utterance) {
    if (utterance == "nothing") {
      return 0;
    } else {
      var words = utterance.split(" ");
      var chars = utterance.split("");
      var negs = filter(function(x) {return x == "!";}, chars);
      return words.length;
    }
  };

  // utility to grab Booleans from world
  var basePropositions = function() {
    var RVs = rand();
    var world = vars(RVs);
    return map(
      function(keyVal) {
        return keyVal[0];
      },
      filter(
        function(keyVal) {
          return typeof(keyVal[1]) == 'boolean';
        },
        _.pairs(world)
      )
    );
  }();

  var getUtterancePrior = function(baseUtterance) {
    // alternatives are:
    //   - nothing + all basic propositions and their negations for most things
    //   - nothing + "B because " if the utterance is "B because X"
    var getAlternativeUtterances = function(baseUtterance) {
      // grab booleans and negate them to get all basic utterances and their negations
      var negPropositions = map(function(p) {return "!" + p + "";}, basePropositions);
      var simplePropositions = negPropositions.concat(basePropositions);
      var words = baseUtterance.split(" ");

      // if the utterance doesn't have "because" in it, all simple props and the utterance
      if (words.length < 2 | words[1] != 'because') {
        return ['nothing', baseUtterance].concat(simplePropositions);
      } else {
        // if utterance does have "because" in it, explain the consequence in some other way
        var resultB = words[0];
        return ['nothing'].concat(
          map(function(simpleProp) {resultB + ' because ' + simpleProp}, simplePropositions)
        );
      }
    };
    var utterances = getAlternativeUtterances(baseUtterance);
    var costs = map(getCostUtterance, utterances);
    return function() {
      var probabilities = map(function(x) {return Math.exp(-x);}, costs);
      return utterances[discrete(probabilities)];
    };
  };

  var speakerERP = cache(function(utterance, world, presup) {
    var utterancePrior = getUtterancePrior(utterance);
    var unfactoredERP = Enumerate(function() {
      var utterance = utterancePrior();
      var interpretation = literalERP(utterance, presup);
      return {
        factor: interpretation == 'impossible' ? -Infinity : interpretation.score([], world),
        result: utterance
      };
    });
    return checkPossible(unfactoredERP);
  });

  var listenerERP = cache(function(utterance, presup) {
    var unfactoredERP = Enumerate(function() {
      var actualRVs = rand();
      var actualWorld = vars(actualRVs);
      var description = speakerERP(utterance, actualWorld, presup);
      return {
        factor: (description == 'impossible' ? -Infinity : description.score([], utterance) * alpha) +
                meaning_factor(presup, actualWorld),
        result: worldstring(actualWorld)
        // can presuppose stuff here, e.g. "B" in "why B?"
      };
    });
    return checkPossible(unfactoredERP);
  });

  var speaker2ERP = function(utterance, world, presup) {
    var utterances = [utterance, 'nothing'];
    return Enumerate(function() {
      var utt = uniformDraw(utterances);
      var interpretation = listenerERP(utt, presup);
      var f = interpretation == 'impossible' ? -Infinity : interpretation.score([], world);
      factor( f );
      return utt == utterance ? 'yes' : 'no';
    });
  };

  // ======== examples =========

  return map(function(consequent) {
    var p = get_prob(counterfactualERP(condition, consequent, initialRVs));
    print('cond=' + condition + ', consequent=' + consequent + ', p=' + p);
    return {
      condition: condition,
      consequent: consequent,
      p: p
    };
  }, consequents);
}

// ======== model specification =========

var bacon = {
  rand : function() {
    return {
      uB: flip(0.9),
      uS: flip(0.9),
      uN: flip(0.1)
    };
  },
  vars: function(rVs) {
    var B = rVs.uB;
    var S = B & rVs.uS;
    var N = S | rVs.uN;
    return {
      B: B,
      S: S,
      N: N
    };
  }
};
var story1 = {
  rand : function() {
    return {
      uA: flip(0.1),
      uB: flip(0.1)
    };
  },
  vars: function(rVs) {
    var A = rVs.uA;
    var B = rVs.uB;
    return {
      A: A,
      B: B
    };
  }
};
var story2 = {
  rand : function() {
    return {
      uA: flip(0.1),
      uAB: flip(0.75),
      uBC: flip(0.75)
    };
  },
  vars: function(rVs) {
    var A = rVs.uA;
    var B = A & rVs.uAB;
    var C = B & rVs.uBC;
    return {
      A: A,
      B: B,
      C: C
    };
  }
};
var story3 = {
  rand : function() {
    return {
      uA: flip(0.25),
      uB: flip(0.1)
    };
  },
  vars: function(rVs) {
    var A = rVs.uA;
    var B = rVs.uB;
    var C = (A & !B) | (!A & B) ? true : false;
    return {
      A: A,
      B: B,
      C: C
    };
  }
};
var story4 = {
  rand : function() {
    return {
      uA: flip(0.9),
      uB: flip(0.9)
    };
  },
  vars: function(rVs) {
    var A = rVs.uA;
    var B = rVs.uB;
    var C = (A | B) ? true : false;
    var D = C;
    return {
      A: A,
      B: B,
      C: C,
      D: D
    };
  }
};
var story5 = {
  rand : function() {
    return {
      uA: flip(0.75),
      uB: flip(0.75),
      uBC: flip(0.9)
    };
  },
  vars: function(rVs) {
    var A = rVs.uA;
    var B = rVs.uB;
    var C = A ? true : (B & rVs.uBC) ? true : false;
    var D = C;
    return {
      A: A,
      B: B,
      C: C,
      D: D
    };
  }
};
var story6 = {
  rand : function() {
    return {
      uA: flip(0.25),
      uAB: flip(0.1),
      uBC: flip(0.1)
    };
  },
  vars: function(rVs) {
    var A = rVs.uA;
    var B = (A & !rVs.uAB) | (!A & rVs.uAB) ? true : false;
    var C = (B & !rVs.uBC) | (!B & rVs.uBC) ? true : false;
    return {
      A: A,
      B: B,
      C: C
    };
  }
}

var s = 0.53;
print("bacon, stickiness=0.5")
model(bacon.rand, bacon.vars, '!S', ['B'], {uB: true, uS: true, uN: true}, 0.5);
print("story1, stickiness=" + s)
model(story1.rand, story1.vars, '!A', ['B'], {uA: true, uB: true}, s);
print("story2, stickiness=" + s)
model(story2.rand, story2.vars, '!B', ['A', 'B', 'C'], {uA: true, uAB: true, uBC: true}, s);
print("story3, stickiness=" + s)
model(story3.rand, story3.vars, '!A', ['A', 'B', 'C'], {uA: true, uB: true}, s);
print("story4, stickiness=" + s)
model(story4.rand, story4.vars, 'C', ['A', 'B', 'C', 'D'], {uA: false, uB: false}, s);
print("story5, stickiness=" + s);
model(story5.rand, story5.vars, '!C', ['A', 'B', 'C', 'D'], {uA: true, uB: true, uBC: true}, s);
print("story6, stickiness=" + s)
model(story6.rand, story6.vars, 'B', ['A', 'B', 'C'], {uA: false, uAB: false, uBC: true}, s);

"finished"